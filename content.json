{"meta":{"title":"唐耀的技术博客","subtitle":"tangyao1993.github.io","description":"唐耀的技术博客","author":"tangyao","url":"https://tangyao1993.github.io"},"pages":[{"title":"","date":"2017-11-16T13:21:35.978Z","updated":"2017-11-16T13:21:35.978Z","comments":false,"path":"tags/index.html","permalink":"https://tangyao1993.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-11-16T13:22:06.882Z","updated":"2017-11-16T13:22:06.882Z","comments":false,"path":"categories/index.html","permalink":"https://tangyao1993.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"使用hexo，如果换了电脑怎么更新博客？","slug":"使用hexo，如果换了电脑怎么更新博客？","date":"2017-12-09T06:16:01.000Z","updated":"2017-12-09T06:17:40.022Z","comments":true,"path":"2017/12/09/使用hexo，如果换了电脑怎么更新博客？/","link":"","permalink":"https://tangyao1993.github.io/2017/12/09/使用hexo，如果换了电脑怎么更新博客？/","excerpt":"","keywords":[{"name":"随笔","slug":"随笔","permalink":"https://tangyao1993.github.io/categories/随笔/"}],"text":"当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：1. 使用git clone git@github.com:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）；2. 在本地新拷贝的http://CrazyMilk.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 作者：CrazyMilk链接：https://www.zhihu.com/question/21193762/answer/79109280来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://tangyao1993.github.io/categories/随笔/"}],"tags":[]},{"title":"netty中TCP粘包、拆包问题","slug":"netty中TCP粘包、拆包问题","date":"2017-11-30T06:23:10.000Z","updated":"2017-11-30T06:29:09.407Z","comments":true,"path":"2017/11/30/netty中TCP粘包、拆包问题/","link":"","permalink":"https://tangyao1993.github.io/2017/11/30/netty中TCP粘包、拆包问题/","excerpt":"","keywords":[{"name":"随笔","slug":"随笔","permalink":"https://tangyao1993.github.io/categories/随笔/"}],"text":"tcp粘包拆包问题 tcp粘包拆包问题解决方案","categories":[{"name":"随笔","slug":"随笔","permalink":"https://tangyao1993.github.io/categories/随笔/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://tangyao1993.github.io/tags/Netty/"},{"name":"TCP","slug":"TCP","permalink":"https://tangyao1993.github.io/tags/TCP/"}]},{"title":"Netty:NIO框架","slug":"Netty-NIO框架","date":"2017-11-29T05:36:54.000Z","updated":"2017-11-29T05:57:09.164Z","comments":true,"path":"2017/11/29/Netty-NIO框架/","link":"","permalink":"https://tangyao1993.github.io/2017/11/29/Netty-NIO框架/","excerpt":"","keywords":[{"name":"后台","slug":"后台","permalink":"https://tangyao1993.github.io/categories/后台/"}],"text":"netty是一种NIO框架，对NIO进行了封装，让NIO使用起来更简便。推荐学习文章：http://ifeve.com/netty5-user-guide/ Client：public class Client { public static void main(String[] args) throws Exception { EventLoopGroup workgroup = new NioEventLoopGroup(); Bootstrap b = new Bootstrap(); b.group(workgroup) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override protected void initChannel(SocketChannel sc) throws Exception { sc.pipeline().addLast(new ClientHandler()); } }); ChannelFuture cf1 = b.connect(&quot;127.0.0.1&quot;, 8765).sync(); //buf cf1.channel().writeAndFlush(Unpooled.copiedBuffer(&quot;777&quot;.getBytes())); cf1.channel().closeFuture().sync(); workgroup.shutdownGracefully(); } } ClientHandler:public class ClientHandler extends ChannelHandlerAdapter { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { try { //do something msg ByteBuf buf = (ByteBuf)msg; byte[] data = new byte[buf.readableBytes()]; buf.readBytes(data); String request = new String(data, &quot;utf-8&quot;); System.out.println(&quot;Client: &quot; + request); } finally { ReferenceCountUtil.release(msg); } } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); ctx.close(); } } Server:public class Server { public static void main(String[] args) throws Exception { //1 第一个线程组 是用于接收Client端连接的 EventLoopGroup bossGroup = new NioEventLoopGroup(); //2 第二个线程组 是用于实际的业务处理操作的 EventLoopGroup workerGroup = new NioEventLoopGroup(); //3 创建一个辅助类Bootstrap，就是对我们的Server进行一系列的配置 ServerBootstrap b = new ServerBootstrap(); //把俩个工作线程组加入进来 b.group(bossGroup, workerGroup) //我要指定使用NioServerSocketChannel这种类型的通道 .channel(NioServerSocketChannel.class) //一定要使用 childHandler 去绑定具体的 事件处理器 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override protected void initChannel(SocketChannel sc) throws Exception { sc.pipeline().addLast(new ServerHandler()); } }); //绑定指定的端口 进行监听 ChannelFuture f = b.bind(8765).sync(); //Thread.sleep(1000000); f.channel().closeFuture().sync(); bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } ServerHandler:public class ServerHandler extends ChannelHandlerAdapter { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { //do something msg ByteBuf buf = (ByteBuf)msg; byte[] data = new byte[buf.readableBytes()]; buf.readBytes(data); String request = new String(data, &quot;utf-8&quot;); System.out.println(&quot;Server: &quot; + request); //写给客户端 String response = &quot;我是反馈的信息&quot;; ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;888&quot;.getBytes())); //.addListener(ChannelFutureListener.CLOSE); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); ctx.close(); } }","categories":[{"name":"后台","slug":"后台","permalink":"https://tangyao1993.github.io/categories/后台/"}],"tags":[{"name":"NIO框架","slug":"NIO框架","permalink":"https://tangyao1993.github.io/tags/NIO框架/"},{"name":"Netty","slug":"Netty","permalink":"https://tangyao1993.github.io/tags/Netty/"}]},{"title":"IO、NIO和AIO","slug":"IO、NIO和AIO","date":"2017-11-25T08:09:44.000Z","updated":"2017-11-28T01:53:24.524Z","comments":true,"path":"2017/11/25/IO、NIO和AIO/","link":"","permalink":"https://tangyao1993.github.io/2017/11/25/IO、NIO和AIO/","excerpt":"","keywords":[{"name":"note","slug":"note","permalink":"https://tangyao1993.github.io/categories/note/"}],"text":"","categories":[{"name":"note","slug":"note","permalink":"https://tangyao1993.github.io/categories/note/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://tangyao1993.github.io/tags/IO/"},{"name":"NIO","slug":"NIO","permalink":"https://tangyao1993.github.io/tags/NIO/"},{"name":"AIO","slug":"AIO","permalink":"https://tangyao1993.github.io/tags/AIO/"}]},{"title":"BIO伪异步","slug":"BIO伪异步","date":"2017-11-25T07:14:03.000Z","updated":"2017-11-29T05:59:43.072Z","comments":true,"path":"2017/11/25/BIO伪异步/","link":"","permalink":"https://tangyao1993.github.io/2017/11/25/BIO伪异步/","excerpt":"","keywords":[{"name":"后台","slug":"后台","permalink":"https://tangyao1993.github.io/categories/后台/"}],"text":"为什么需要伪异步？socket编程中每一个socket客户端去连接服务端的时候就需要开启一个线程进行处理，如果客户端过多服务端开启线程数也会过多，导致服务端资源耗尽崩溃 实现伪异步io的方法通过线程池进行解决，这是比较老的解决方法，在jdk1.5之后java提供了nio，可以解决这个问题实现代码如下： 客户端代码public class Client { final static String ADDRESS = &quot;127.0.0.1&quot;; final static int PORT =8765; public static void main(String[] args) { Socket socket = null; BufferedReader in = null; PrintWriter out = null; try { socket = new Socket(ADDRESS, PORT); in = new BufferedReader(new InputStreamReader(socket.getInputStream())); out = new PrintWriter(socket.getOutputStream(), true); out.println(&quot;Client request&quot;); String response = in.readLine(); System.out.println(&quot;Client:&quot; + response); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } finally { if(in != null){ try { in.close(); } catch (Exception e1) { e1.printStackTrace(); } } if(out != null){ try { out.close(); } catch (Exception e2) { e2.printStackTrace(); } } if(socket != null){ try { socket.close(); } catch (Exception e3) { e3.printStackTrace(); } } socket = null; } } } 服务端处理代码public class ServerHandler implements Runnable { private Socket socket; public ServerHandler (Socket socket){ this.socket = socket; } @Override public void run() { BufferedReader in = null; PrintWriter out = null; try { in = new BufferedReader(new InputStreamReader(this.socket.getInputStream())); out = new PrintWriter(this.socket.getOutputStream(), true); String body = null; while(true){ body = in.readLine(); if(body == null) break; System.out.println(&quot;Server:&quot; + body); out.println(&quot;Server response&quot;); } } catch (Exception e) { e.printStackTrace(); } finally { if(in != null){ try { in.close(); } catch (Exception e1) { e1.printStackTrace(); } } if(out != null){ try { out.close(); } catch (Exception e2) { e2.printStackTrace(); } } if(socket != null){ try { socket.close(); } catch (Exception e3) { e3.printStackTrace(); } } socket = null; } } } 服务端代码public class Server { final static int PORT = 8765; public static void main(String[] args) { ServerSocket server = null; BufferedReader in = null; PrintWriter out = null; try { server = new ServerSocket(PORT); System.out.println(&quot;server start&quot;); Socket socket = null; HandlerExecutorPool executorPool = new HandlerExecutorPool(50, 1000); while(true){ socket = server.accept(); executorPool.execute(new ServerHandler(socket)); } } catch (Exception e) { e.printStackTrace(); } finally { if(in != null){ try { in.close(); } catch (Exception e1) { e1.printStackTrace(); } } if(out != null){ try { out.close(); } catch (Exception e2) { e2.printStackTrace(); } } if(server != null){ try { server.close(); } catch (Exception e3) { e3.printStackTrace(); } } server = null; } } } 自定义线程池public class HandlerExecutorPool { private ExecutorService executor; public HandlerExecutorPool(int maxPoolSize, int queueSize){ this.executor = new ThreadPoolExecutor( Runtime.getRuntime().availableProcessors(), maxPoolSize, 120L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(queueSize)); } public void execute(Runnable task){ this.executor.execute(task); } }","categories":[{"name":"后台","slug":"后台","permalink":"https://tangyao1993.github.io/categories/后台/"}],"tags":[{"name":"BIO","slug":"BIO","permalink":"https://tangyao1993.github.io/tags/BIO/"},{"name":"网络编程","slug":"网络编程","permalink":"https://tangyao1993.github.io/tags/网络编程/"}]},{"title":"redis遇到的坑","slug":"redis遇到的坑","date":"2017-11-16T11:45:30.000Z","updated":"2017-11-16T14:07:28.097Z","comments":true,"path":"2017/11/16/redis遇到的坑/","link":"","permalink":"https://tangyao1993.github.io/2017/11/16/redis遇到的坑/","excerpt":"","keywords":[{"name":"note","slug":"note","permalink":"https://tangyao1993.github.io/categories/note/"}],"text":"1、 Error condition on socket for SYNC: Connection refused解决方案：在redis主服务器上的redis.conf中修改bind字段，将bind 127.0.0.1修改为bind 0.0.0.0原因：如果redis主服务器绑定了127.0.0.1，那么跨服务器IP的访问就会失败，从服务器用IP和端口访问主的时候，主服务器发现本机6379端口绑在了127.0.0.1上，也就是只能本机才能访问，外部请求会被过滤，这是linux的网络安全策略管理的。如果bind的IP地址是172.168.10.70，那么本机通过localhost和127.0.0.1、或者直接输入命令redis-cli登录本机redis也就会失败了。只能加上本机ip才能访问到。所以，在研发、测试环境可以考虑bind 0.0.0.0，线上生产环境建议绑定IP地址。 2、 哨兵模式出现不能切换主节点问题：failover-abort-no-good-slave master mymaster在redis主服务器上和从服务器的redis.conf中修改bind字段，将bind 127.0.0.1修改为bind 0.0.0.0","categories":[{"name":"note","slug":"note","permalink":"https://tangyao1993.github.io/categories/note/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://tangyao1993.github.io/tags/redis/"}]},{"title":"hexo常用操作","slug":"hexo常用操作","date":"2017-11-15T13:11:55.671Z","updated":"2017-11-16T14:05:54.155Z","comments":true,"path":"2017/11/15/hexo常用操作/","link":"","permalink":"https://tangyao1993.github.io/2017/11/15/hexo常用操作/","excerpt":"","keywords":[{"name":"note","slug":"note","permalink":"https://tangyao1993.github.io/categories/note/"}],"text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"note","slug":"note","permalink":"https://tangyao1993.github.io/categories/note/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://tangyao1993.github.io/tags/hexo/"}]}]}